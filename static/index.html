<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>LaunchDarkly CSV Export</title>
		<style>
			:root {
				/* Grayscale colours */
				--white: #ffffff;
				--gray01: #f8f8f8;
				--gray02: #e6e6e6;
				--gray03: #d1d3d4;
				--gray04: #bcbec0;
				--gray05: #a7a9ac;
				--gray06: #939598;
				--gray07: #6d6e71;
				--gray08: #58595b;
				--gray09: #414042;
				--black00: #2c2c2c;
				--black01: #282828;
				--black02: #212121;
				--black03: #191919;
				--black04: #000000;

				/* Brand colours */
				--yellow: #ebff38;
				--blue: #405bff;
				--pink: #ff386b;
				--cyan: #3dd6f5;
				--purple: #a34fde;

				/* Additional */
				--border: #d8e5ee;

				/* Black/white */
				--off-white: #f8f8f8;
				--black: #000000;
				--black100: #282828;
				--black200: #212121;
				--black300: #191919;
				--gray100: #e6e6e6;
				--gray200: #d1d3d4;
				--gray300: #bcbec0;
				--gray400: #a7a9ac;
				--gray500: #939598;
				--gray600: #6d6e71;
				--gray700: #58595b;
				--gray800: #414042;
				--gray900: #353535;
				--blue600: #2e3f7f;
				/* User notification colours */
				--success: #00da7b;
				--warning: #eec340;
				--error: #e83b3b;

				/* Body font colour */
				--light-text: #ffffff;
				--dark-text: #282828;
				--text-gradient-a: #edf4c9;
				--text-gradient-b: #9eadf1;

				/* Typography */
				--font-primary: 'Audimat 3000';
				--font-secondary: 'Sohne';
			}
			body {
				font-family: var(--font-secondary);
				line-height: 1.6;
				font-size: 12pt;
				color: var(--dark-text);
				background: var(--off-white);
				margin: 20px;
				min-width: 540px;
			}
			.container {
				max-width: 800px;
				margin: 0 auto;
			}
			h2 {
				padding-top: 0;
				margin-top: 0;
			}
			.fields-form {
				margin-bottom: 20px;
			}
			label {
				font-weight: bold;
			}
			.selectors-container {
				display: flex;
				align-items: flex-start;
				gap: 2rem;
				margin-bottom: 1rem;
			}
			
			.selector-group {
				display: flex;
				flex-direction: column;
				min-width: 300px;
			}
			
			.selector-group label {
				margin-bottom: 0.5rem;
				font-weight: bold;
			}
			
			.loading-indicators {
				height: 40px;
				display: flex;
				align-items: center;
				margin-top: 0.5rem;
			}
			
			.auth-controls {
				display: flex;
				align-items: flex-end;
				margin-top: 1.5rem;
			}
			
			.logout-btn {
				background-color: var(--gray600);
				color: var(--white);
				border: none;
				padding: 0.5rem 1rem;
				border-radius: 4px;
				cursor: pointer;
				font-size: 12pt;
				transition: background-color 0.3s ease;
			}
			
			.logout-btn:hover {
				background-color: var(--gray700);
			}
			
			.project-select-container {
				position: relative;
				display: inline-block;
				min-width: 300px;
			}
			
			.project-search-input {
				width: 100%;
				padding: 0.5rem;
				border: 1px solid var(--gray200);
				border-radius: 4px;
				font-size: 12pt;
				margin-bottom: 0.5rem;
			}
			
			.project-dropdown {
				position: absolute;
				top: 100%;
				left: 0;
				right: 0;
				max-height: 200px;
				overflow-y: auto;
				background: var(--white);
				border: 1px solid var(--gray200);
				border-radius: 4px;
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
				z-index: 1000;
				display: none;
			}
			
			.project-option {
				padding: 0.5rem;
				cursor: pointer;
				border-bottom: 1px solid var(--gray100);
			}
			
			.project-option:hover {
				background-color: var(--gray01);
			}
			
			.project-option.selected {
				background-color: var(--blue);
				color: var(--white);
			}
			
			.project-select-display {
				width: 100%;
				min-width: 300px;
				padding: 0.5rem;
				border: 1px solid var(--gray200);
				border-radius: 4px;
				background: var(--white);
				cursor: pointer;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			
			.project-select-display:hover {
				border-color: var(--gray300);
			}
			table {
				width: 100%;
				border-collapse: collapse;
			}
			#env-select {
				width: 100%;
				min-width: 300px;
				padding: 0.5rem;
				border: 1px solid var(--gray200);
				border-radius: 4px;
				font-size: 12pt;
			}

			table,
			th,
			td {
				border: 1px solid var(--gray100);
			}

			th,
			td {
				padding: 8px;
				text-align: left;
			}
			thead tr {
				background-color: var(--gray900);
				color: var(--white);
			}
			thead th {
				border: none;
			}
			/* alternate row colors */
			tbody tr:nth-child(odd) {
				background-color: var(--white);
			}
			tbody tr:nth-child(even) {
				background-color: var(--off-white);
			}
			details {
				border: 1px solid var(--border);
				border-radius: 4px;
				padding: 0.5em 0.5em 0;
				background-color: var(--gray01);
				min-width: 12em;
			}

			summary {
				font-weight: bold;
				margin: -0.5em -0.5em 0;
				padding: 0.5em;
				background-color: var(--gray900);
				color: var(--white);
				border-radius: 4px;
				cursor: pointer;
			}

			details[open] {
				padding: 0.5em;
			}
			#exportButton {
				align-self: flex-start;
				flex-basis: 12rem;
				background-color: var(--blue);
				color: var(--white);
				font-weight: bold;
				border: none;
				padding: 1em;
				cursor: pointer;
				font-family: var(--font-secondary);
				border-radius: 4px;
				transition: background-color 0.3s ease;
			}

			#exportButton:hover {
				background-color: var(--blue600);
			}

			details[open] summary {
				border-bottom: 1px solid var(--border);
				margin-bottom: 0.5em;
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}
			.export-container {
				display: flex;
				align-items: center;
				gap: 1rem;
				margin-bottom: 20px;
			}
			.spinner {
				display: inline-block;
				opacity: 0;
				border: 4px solid rgba(0, 0, 0, 0.1);
				border-left-color: var(--blue);
				border-radius: 50%;
				width: 0.5rem;
				height: 0.5rem;
				animation: spin 1s linear infinite;
				margin-right: 0.5rem;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			#preview {
				background-color: var(--white);
				border: 1px solid var(--border);
				padding: 1rem;
				width: max-content;
				height: max-content;
				border-radius: 5px;
			}
			
			.progress-container {
				display: none;
				padding: 8px;
				background-color: var(--gray01);
				border-radius: 4px;
				border: 1px solid var(--border);
				flex: 1;
				margin-left: 0.5rem;
			}
			
			.progress-bar {
				width: 100%;
				height: 20px;
				background-color: var(--gray200);
				border-radius: 10px;
				overflow: hidden;
				margin: 5px 0;
			}
			
			.progress-fill {
				height: 100%;
				background-color: var(--blue);
				transition: width 0.3s ease;
				border-radius: 10px;
			}
			
			.progress-text {
				font-size: 12px;
				color: var(--gray600);
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<form>
				<div class="selectors-container">
					<div class="selector-group">
						<label for="project-select">Project:</label>
						<div class="project-select-container">
							<div class="project-select-display" onclick="toggleProjectDropdown()">
								<span id="project-display-text">Select a project...</span>
								<span>â–¼</span>
							</div>
							<div class="project-dropdown" id="project-dropdown">
								<input type="text" class="project-search-input" id="project-search" placeholder="Search projects..." oninput="filterProjects()">
								<div id="project-options">
									<!-- Project options will be populated here -->
								</div>
							</div>
						</div>
						<div class="loading-indicators">
							<div id="project-spinner" class="spinner"></div>
							<div id="project-progress" class="progress-container">
								<div class="progress-bar">
									<div class="progress-fill" id="project-progress-fill"></div>
								</div>
								<div class="progress-text" id="project-progress-text">Loading projects...</div>
							</div>
						</div>
					</div>
					<div class="selector-group">
						<label for="env-select">Environment:</label>
						<select id="env-select" onchange="loadFlagsAndStatuses()" placeholder="Environment">
							<!-- Environments will be populated here -->
						</select>
						<div class="loading-indicators">
							<div id="env-spinner" class="spinner"></div>
							<div id="env-progress" class="progress-container">
								<div class="progress-bar">
									<div class="progress-fill" id="env-progress-fill"></div>
								</div>
								<div class="progress-text" id="env-progress-text">Loading environments...</div>
							</div>
						</div>
					</div>
					<div class="auth-controls">
						<button type="button" onclick="logout()" class="logout-btn">Logout</button>
					</div>
				</div>
				<div class="export-container">
					<details>
						<summary>Fields</summary>
						<label><input type="checkbox" name="fields" value="key" onchange="updatePreview()" checked /> Key</label><br />
						<label><input type="checkbox" name="fields" value="name" onchange="updatePreview()" checked /> Name</label><br />
						<label>
							<input type="checkbox" name="fields" value="description" onchange="updatePreview()" checked />
							Description </label
						><br />
						<label
							><input type="checkbox" name="fields" value="maintainer" onchange="updatePreview()" checked /> Maintainer</label
						><br />
						<label><input type="checkbox" name="fields" value="tags" onchange="updatePreview()" checked /> Tags</label><br />
						<label><input type="checkbox" name="fields" value="archived" onchange="updatePreview()" checked /> Archived</label
						><br />
						<label
							><input type="checkbox" name="fields" value="deprecated" onchange="updatePreview()" checked /> Deprecated</label
						><br />
						<label
							><input type="checkbox" name="fields" value="creationDate" onchange="updatePreview()" checked /> Creation
							Date</label
						><br />
						<label><input type="checkbox" name="fields" value="env" onchange="updatePreview()" checked /> Environment Key</label
						><br />
						<label
							><input type="checkbox" name="fields" value="envName" onchange="updatePreview()" checked /> Environment
							Name</label
						><br />
						<label
							><input type="checkbox" name="fields" value="lastModified" onchange="updatePreview()" checked /> Last
							Modified</label
						><br />
						<label><input type="checkbox" name="fields" value="status" onchange="updatePreview()" checked /> Status</label
						><br />
						<label
							><input type="checkbox" name="fields" value="lastEvaluated" onchange="updatePreview()" checked /> Last
							Evaluated</label
						><br />
						<label
							><input type="checkbox" name="fields" value="readyToArchive" onchange="updatePreview()" checked /> Ready to Archive</label
						><br />
						<label>
							<input type="checkbox" name="fields" value="readyForCodeRemoval" onchange="updatePreview()" checked /> Ready for Code Removal
						</label>
					</details>
					<button type="button" id="exportButton" onclick="doExport()">Export to CSV</button>
					<div id="export-spinner" class="spinner"></div>
				</div>
			</form>
		</div>
		<div id="preview">
			<h2>Live Preview</h2>
			<table id="preview-table">
				<thead>
					<tr id="preview-header">
						<!-- Headers will be populated here -->
					</tr>
				</thead>
				<tbody id="preview-body">
					<!-- Data will be populated here -->
				</tbody>
			</table>
		</div>

		<script>
			let globalFlags = [];
			let globalFlagStatuses = [];
			let globalProjects = [];
            const API_BASE = 'https://app.launchdarkly.com';
			let globalAccessToken = null;

			function getAccessToken() {
				if (globalAccessToken) {
					return globalAccessToken;
				} else {
					// First check localStorage for existing token
					const storedToken = localStorage.getItem('ld_access_token');
					if (storedToken) {
						globalAccessToken = `Bearer ${storedToken}`;
						return storedToken;
					}
					
					// Then check URL hash for new token from OAuth flow
					const hash = window.location.hash;
					const params = new URLSearchParams(hash.substring(1));
					console.log('access token is', params);
					const accessToken = params.get('access_token');
					if (accessToken) {
						// Store token in localStorage for persistence
						localStorage.setItem('ld_access_token', accessToken);
						globalAccessToken = `Bearer ${accessToken}`;
						window.history.replaceState({}, null, window.location.pathname);
						return accessToken;
					} else {
						redirectToLogin();
						return null;
					}
				}
			}

			function redirectToLogin() {
				window.location.href = '/oauth/login';
			}
			
			function logout() {
				// Clear stored token
				localStorage.removeItem('ld_access_token');
				globalAccessToken = null;
				// Redirect to login
				redirectToLogin();
			}
			
			function handleTokenExpiration() {
				// Clear stored token if it's expired
				localStorage.removeItem('ld_access_token');
				globalAccessToken = null;
				redirectToLogin();
			}
			function dateSlug() {
				const date = new Date();
				return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
			}

			function safeFileName(name) {
				return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
			}
			async function doExport() {
				const accessToken = getAccessToken();

				const selectedFields = getSelectedFields();
				
				// Get the selected project key from the display text
				const selectedProjectName = document.getElementById('project-display-text').textContent;
				const selectedProject = globalProjects.find(p => p.name === selectedProjectName);
				
				if (!selectedProject) {
					alert('Please select a project first');
					return;
				}
				
				const projectKey = selectedProject.key;
				const envKey = document.getElementById('env-select').value;
				const spinner = document.getElementById('export-spinner');
				const exportButton = document.getElementById('exportButton');
				const limit = 20;
				exportButton.disabled = true;

				spinner.style.opacity = 1;

				try {
					exportButton.textContent = 'Loading flags...';
					const flags = await getAll(
						accessToken,
						`https://app.launchdarkly.com/api/v2/flags/${projectKey}?limit=${limit}&expand=evaluation,archiveChecks&env=${envKey}`,
					);
					exportButton.textContent = 'Loading statuses...';
					const flagStatuses = await getAll(
						accessToken,
						`https://app.launchdarkly.com/api/v2/flag-statuses/${projectKey}/${envKey}?limit=${limit}`,
					);
					exportButton.textContent = 'Exporting...';
					console.log('got', flags, flagStatuses);
					const report = processFlags(flags, envKey, flagStatuses, selectedFields);
					const csv = report
						.map((row) =>
							selectedFields
								.map((field) => {
									if (Array.isArray(row[field])) {
										return JSON.stringify(row[field].join(','));
									} else {
										return JSON.stringify(row[field]);
									}
								})
								.join(','),
						)
						.join('\n');
					const firstLine = selectedFields.join(',');
					const blob = new Blob([firstLine, '\n', csv], { type: 'text/csv' });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = `launchdarkly-export-${projectKey}-${dateSlug()}.csv`;
					a.click();
				} catch (error) {
					console.error('Error exporting data:', error);
					alert('Failed to export data: ' + error);
				} finally {
					spinner.style.opacity = 0;
					exportButton.disabled = false;
					exportButton.textContent = 'Export to CSV';
				}
				// get all flags and statuses
			}

			async function fetchProjects(accessToken) {
				return getAll(accessToken, 'https://app.launchdarkly.com/api/v2/projects?limit=50', updateProjectProgress);
			}

			async function fetchEnvironments(accessToken, projectKey) {
				return getAll(accessToken, `https://app.launchdarkly.com/api/v2/projects/${projectKey}/environments?limit=50`, updateEnvironmentProgress);
			}
			// Function to make an HTTP GET request with retry logic (to handle failures and rate limits)
			async function get(accessToken, url, maxRetries = 5) {
				for (let attempt = 0; attempt < maxRetries; attempt++) {
					try {
						const response = await fetch(url, {
							headers: {
								Authorization: `${accessToken}`,
							},
						});

						// If the request is successful, return the JSON response
						if (response.ok) {
							return await response.json();
						}
						// If the request exceeds the rate limit, handle it by pausing
						else if (response.status === 429) {
							const timeout = parseInt(response.headers.get('x-ratelimit-reset')) || 1000;
							console.info(`Rate limit exceeded. Sleeping for ${timeout}ms...`);
							await sleep(timeout); // Sleep for the duration specified in the headers
						}
						// For any other errors, throw an error with the response status
						else {
							console.error(`Error: ${response.statusText}`);
							// Check if token is expired (401 Unauthorized)
							if (response.status === 401) {
								handleTokenExpiration();
								return;
							}
							throw new Error(`Failed to fetch data: ${response.status}`);
						}
					} catch (error) {
						console.error(`Attempt ${attempt + 1} failed. Retrying...`);
					}
				}

				// If all retry attempts fail, throw an error
				throw new Error(`Failed to fetch data after ${maxRetries} attempts`);
			}
			// Helper function to sleep for a given number of milliseconds (used for rate limiting)
			function sleep(ms) {
				return new Promise((resolve) => setTimeout(resolve, ms));
			}
    
			// Function to fetch all paginated results from the API (handles pagination automatically)
			async function getAll(accessToken, url, progressCallback = null) {
				let nextUrl = url;
				const results = [];
				let totalCount = 0;
				let loadedCount = 0;

				// Loop through paginated responses until there are no more pages
				while (nextUrl) {
					const response = await get(accessToken, nextUrl);
					const {
						items,
						totalCount: responseTotalCount,
						_links: { next },
					} = response;
					
					// Set total count from first response
					if (totalCount === 0 && responseTotalCount) {
						totalCount = responseTotalCount;
					}
					
					results.push(...items);
					loadedCount += items.length;

					// Update progress if callback provided
					if (progressCallback && totalCount > 0) {
						const progress = Math.min((loadedCount / totalCount) * 100, 100);
						progressCallback(progress, loadedCount, totalCount);
					}

					// Check if there is a "next" page, and update the next URL if available
					nextUrl = next && next.href ? API_BASE + next.href : null;
				}

				// Return the combined list of items from all pages
				return results;
			}
			function updateProjectProgress(progress, loaded, total) {
				const progressContainer = document.getElementById('project-progress');
				const progressFill = document.getElementById('project-progress-fill');
				const progressText = document.getElementById('project-progress-text');
				
				progressContainer.style.display = 'block';
				progressFill.style.width = `${progress}%`;
				progressText.textContent = `Loading projects: ${loaded} of ${total} (${Math.round(progress)}%)`;
			}

			function updateEnvironmentProgress(progress, loaded, total) {
				const progressContainer = document.getElementById('env-progress');
				const progressFill = document.getElementById('env-progress-fill');
				const progressText = document.getElementById('env-progress-text');
				
				progressContainer.style.display = 'block';
				progressFill.style.width = `${progress}%`;
				progressText.textContent = `Loading environments: ${loaded} of ${total} (${Math.round(progress)}%)`;
			}

			function toggleProjectDropdown() {
				const dropdown = document.getElementById('project-dropdown');
				const isVisible = dropdown.style.display === 'block';
				dropdown.style.display = isVisible ? 'none' : 'block';
				
				if (!isVisible) {
					document.getElementById('project-search').focus();
				}
			}

			function filterProjects() {
				const searchTerm = document.getElementById('project-search').value.toLowerCase();
				const projectOptions = document.getElementById('project-options');
				const options = projectOptions.querySelectorAll('.project-option');
				
				options.forEach(option => {
					const projectName = option.textContent.toLowerCase();
					if (projectName.includes(searchTerm)) {
						option.style.display = 'block';
					} else {
						option.style.display = 'none';
					}
				});
			}

			function selectProject(projectKey, projectName) {
				document.getElementById('project-display-text').textContent = projectName;
				document.getElementById('project-dropdown').style.display = 'none';
				document.getElementById('project-search').value = '';
				
				// Trigger environment population
				populateEnvironments();
			}

			function populateProjectOptions() {
				const projectOptions = document.getElementById('project-options');
				projectOptions.innerHTML = '';
				
				globalProjects.forEach(project => {
					const option = document.createElement('div');
					option.className = 'project-option';
					option.textContent = project.name;
					option.onclick = () => selectProject(project.key, project.name);
					projectOptions.appendChild(option);
				});
			}

			async function populateProjects() {
				const accessToken = getAccessToken();

				try {
					document.getElementById('project-spinner').style.display = 'inline-block';
					document.getElementById('project-progress').style.display = 'none';
					const projects = await fetchProjects(accessToken);
					
					// Store projects globally
					globalProjects = projects;
					
					// Populate the dropdown options
					populateProjectOptions();
					
					// Select the first project by default if available
					if (projects.length > 0) {
						selectProject(projects[0].key, projects[0].name);
					}
				} catch (error) {
					console.error('Error fetching projects:', error);
				} finally {
					document.getElementById('project-spinner').style.opacity = 0;
					document.getElementById('project-progress').style.display = 'none';
				}
			}

			async function populateEnvironments() {
				const accessToken = getAccessToken();

				// Get the selected project key from the display text
				const selectedProjectName = document.getElementById('project-display-text').textContent;
				const selectedProject = globalProjects.find(p => p.name === selectedProjectName);
				
				if (!selectedProject) {
					console.error('No project selected');
					return;
				}
				
				const projectKey = selectedProject.key;
				try {
					document.getElementById('env-spinner').style.opacity = 1;
					document.getElementById('env-progress').style.display = 'none';
					const environments = await fetchEnvironments(accessToken, projectKey);
					const envSelect = document.getElementById('env-select');
					envSelect.innerHTML = '';

					environments.forEach((env) => {
						const option = document.createElement('option');
						option.value = env.key;
						option.textContent = env.name;
						envSelect.appendChild(option);
					});

					// Load flags and statuses for the first environment by default
					loadFlagsAndStatuses();
				} catch (error) {
					console.error('Error fetching environments:', error);
				} finally {
					document.getElementById('env-spinner').style.opacity = 0;
					document.getElementById('env-progress').style.display = 'none';
				}
			}

			async function fetchFlags(accessToken, projectKey, envKey, limit = 20) {
				return get(
					accessToken,
					`https://app.launchdarkly.com/api/v2/flags/${projectKey}?expand=evaluation,archiveChecks&env=${envKey}&limit=${limit}`,
				);
			}

			async function fetchFlagStatuses(accessToken, projectKey, envKey, limit = 20) {
				return get(accessToken, `https://app.launchdarkly.com/api/v2/flag-statuses/${projectKey}/${envKey}?limit=${limit}`);
			}

			async function loadFlagsAndStatuses() {
				const accessToken = getAccessToken();
				if (!accessToken) {
					//redirectToLogin();
					return;
				}

				// Get the selected project key from the display text
				const selectedProjectName = document.getElementById('project-display-text').textContent;
				const selectedProject = globalProjects.find(p => p.name === selectedProjectName);
				
				if (!selectedProject) {
					console.error('No project selected');
					return;
				}
				
				const projectKey = selectedProject.key;
				const envKey = document.getElementById('env-select').value;
				const limit = 100;

				try {
					document.getElementById('env-spinner').style.opacity = 1;
					const flags = await fetchFlags(accessToken, projectKey, envKey);
					const flagStatuses = await fetchFlagStatuses(accessToken, projectKey, envKey, limit);

					globalFlags = flags.items;
					globalFlagStatuses = flagStatuses.items;

					updatePreview();
				} catch (error) {
					console.error('Error fetching flags and statuses:', error);
				} finally {
					document.getElementById('env-spinner').style.opacity = 0;
				}
			}
			function millisecondTimestampToString(millis) {
				// if it fails returned null
				try {
					return (millis && new Date(Math.floor(millis)).toISOString()) || null;
				} catch (error) {
					console.warn('failed to parse timestamp', millis);
					return null;
				}
			}
			function processFlags(flags, envKey, flagStatuses, selectedFields) {
				return flags.map((flag) => {
					const {
						key,
						name,
						tags,
						description,
						_maintainer: maintainer,
						archived,
						deprecated,
						creationDate,
						stale,
						_links: {
							self: { href: flagLink },
						},
						environments,
					} = flag;

					const envDetails = environments[envKey];
					const lastModified = envDetails ? envDetails.lastModified : null;

					const flagStatus = flagStatuses.find(
						({
							_links: {
								parent: { href: parentLink },
							},
						}) => parentLink === flagLink,
					);

					return {
						key,
						name,
						description,
						maintainer: maintainer && maintainer.email,
						tags,
						archived,
						deprecated,
						creationDate: millisecondTimestampToString(creationDate),
						env: envKey,
						envName: envDetails ? envDetails._environmentName : null,
						lastModified: millisecondTimestampToString(lastModified),
						status: flagStatus ? flagStatus.name : null,
						lastEvaluated: flagStatus ? flagStatus.lastRequested : null,
						readyToArchive: stale?.readyToArchive,
						readyForCodeRemoval: stale?.readyForCodeRemoval,
					};
				});
			}
			function getSelectedFields() {
				return Array.from(document.querySelectorAll('input[name="fields"]:checked')).map((input) => input.value);
			}
			async function updatePreview() {
				const selectedFields = getSelectedFields();
				const headerRow = document.getElementById('preview-header');
				const body = document.getElementById('preview-body');

				// Clear existing preview
				headerRow.innerHTML = '';
				body.innerHTML = '';

				// Populate header
				selectedFields.forEach((field) => {
					const th = document.createElement('th');
					th.textContent = field;
					headerRow.appendChild(th);
				});
				const envKey = document.getElementById('env-select').value;

				const report = processFlags(globalFlags, envKey, globalFlagStatuses, selectedFields);

				// Populate body with fetched data
				report.forEach((rowData) => {
					const tr = document.createElement('tr');
					selectedFields.forEach((field) => {
						const td = document.createElement('td');

						td.textContent = rowData[field];

						tr.appendChild(td);
					});
					body.appendChild(tr);
				});
			}

			document.addEventListener('DOMContentLoaded', () => {
				const accessToken = getAccessToken();
				if (accessToken) {
					populateProjects();
				}
				
				// Close dropdown when clicking outside
				document.addEventListener('click', (event) => {
					const dropdown = document.getElementById('project-dropdown');
					const container = document.querySelector('.project-select-container');
					
					if (!container.contains(event.target)) {
						dropdown.style.display = 'none';
					}
				});
			});
		</script>
	</body>
</html>
